## 关联图谱
关联图谱是一种使用图来表示实体之间关联关系的数据组织结构。
在社交网络分析中，关联图谱有着广泛的应用。通过对社交网络分析，可以发现虚拟社区、评估个体影响力、探索信息传播规律等等。
可见关联图谱具有着强大的挖掘潜在信息能力。
同样，关联图谱在金融风控和反欺诈场景也有着广泛的应用，并起到了巨大的作用。
比如，在游戏代充值场景中，通过对手机和用户构成的网络分析，发现某个手机上注册的不同用户数过多，说明这个手机是非常可疑的了。
再比如，在反欺诈场景中，通过对IP和设备的网络分析，发现某个IP C段上出现的设备数过多，说明这个IP C段的网络可能是团伙欺诈网络了。

在本节中，我们主要讨论关联图谱中一度关联和二度关联特征的计算。
由于是针对实时流数据的分析，所以关联图谱的计算也需要将时间窗口考虑在内。

### 一度关联
#### 定义
一度关联是指关联图谱中的一个节点有多少个其它节点与之相邻。
实时流上的一度关联通常是为了统计一段时间内，某种属性上另一种属性不同取值的个数。
比如过去一周内在同一个设备上注册的不同用户数、过去24小时同一IP C段"220.181.111"出现的不同设备数等等。

#### 计算方法
对于一度关联而言，我们只需要在每个时间窗口内，用一个集合（set）来记录所有不同的取值。
当新事件到达时，将相关属性的取值添加到集合即可。

#### 更新计算
记变量$$X$$的值域为集合$$S_X=\{X_1, X_2, X_3, \cdots\}$$，
变量$$Y$$的值域为集合$$S_Y=\{Y_1, Y_2, Y_3, \cdots\}$$，
用`SET(X_i)`记录$$X=X_i$$上出现的不同$$Y$$值的集合，故`SET(X_i)`是$$S_Y$$的子集。
当新事件到达，并且其$$X$$取值为`X_i`，$$Y$$取值为`Y_j`时，更新方法如下：

```
SET(X_i) = SET(X_i) + {Y_j}
```

#### 查询计算
直接返回集合中元素的个数即可。

```
return SET(X_i).size()
```

#### 窗口合并
设$$SET(X_i)_{t1}$$是窗口$$t_1$$上，$$X=X_i$$上出现的不同$$Y$$值集合，
设$$SET(X_i)_{t2}$$是窗口$$t_2$$上，$$X=X_i$$上出现的不同$$Y$$值集合。
则合并两个窗口后的一度关联值是：

$$
SET(X_i)=SET(X_i)_{t1}+SET(X_i)_{t2}
return  SET(X_i).size()
$$

#### 算子
```
COUNT_DISTINCT(time, event_type, target[=value], on1[=value], on2[=value], ...)
```

算子使用样例

```
过去一周内在同一个设备上注册的不同用户数
COUNT_DISTINCT(7d, create_account, userid, device_id)

过去24小时同一IP C段"220.181.111"出现的不同设备数
COUNT_DISTINCT(24h, login, device_id, ip_seg24="220.181.111")
```

### 二度关联
#### 定义
二度关联是对一度关联的扩展，它是由节点的一度关联节点再做一度关联的节点数。
比如过去一周内在同一个设备上注册的用户登录过的设备数。

#### 计算方法
二度关联的计算整体而言会包含两个步骤。第一步是获取原节点所有一度关联节点的集合。
第二步则是遍历这个集合，在获取其中每个节点的一度关联节点后，求这些节点的并集。
最后得到的并集就是原节点的二度关联节点集合。

由于二度关联这种天生的"两部走"过程，我们在实现二度关联的计算时，
也将这两个步骤分开。第一步是求一个集合，第二步则与一度关联的计算类似。

#### 更新计算
记变量$$X$$的值域为集合$$S_X=\{X_1, X_2, X_3, \cdots\}$$，
变量$$Y$$的值域为集合$$S_Y=\{Y_1, Y_2, Y_3, \cdots\}$$，
变量$$Z$$的值域为集合$$S_Z=\{Z_1, Z_2, Z_3, \cdots\}$$，
用`SET_Y(X_i)`记录$$X=X_i$$上出现的不同$$Y$$值的集合，故`SET_Y(X_i)`是$$S_Y$$的子集。
用`SET_Z(Y_j)`记录$$Y=Y_j$$上出现的不同$$Z$$值的集合，故`SET_Z(Y_j)`是$$S_Z$$的子集。
当新事件到达时，如果这个事件代表的是$$X$$上$$Y$$的发生，并且其$$X$$取值为`X_i`，$$Y$$取值为`Y_j`，则更新：
```
SET_Y(X_i) = SET_Y(X_i) + {Y_j}
```
如果这个事件代表的是$$Y$$上$$Z$$的发生，并且其$$Y$$取值为`Y_j`，$$Z$$取值为`Z_k`时，则更新：
```
SET_Z(Y_j) = SET_Z(Y_j) + {Z_k}
```

#### 查询计算
直接返回集合中元素的个数即可。

```
z_set = new Set()
for Y_j in SET_Y(X_i):
    z_set += SET_Z(Y_j)
return z_set.size()
```

记这个返回值为$$SET2(X_i)$$。

#### 窗口合并
设$$SET2(X_i)_{t1}$$是窗口$$t_1$$上，$$X=X_i$$的二度关联$$Z$$值集合，
设$$SET2(X_i)_{t2}$$是窗口$$t_2$$上，$$X=X_i$$的二度关联$$Z$$值集合。
则合并两个窗口后的一度关联值是：

$$
SET2(X_i) = SET2(X_i)_{t1} + SET2(X_i)_{t2}
return  SET2(X_i).size()
$$

#### 算子

一度关联节点集合算子：

```
SET(time, event_type, target[=value], on1[=value], on2[=value], ...)
```

基于一度关联节点集合计算二度关联节点数的算子：

```
FLAT_COUNT_DISTINCT(time, event_type, target[=value], SET(time, event_type, target[=value], on1[=value], on2[=value], ...), on2[=value], ...)
```

算子使用样例：

```
过去一周内在同一个设备上注册的用户登录过的设备数
FLAT_COUNT_DISTINCT(7d, login, device_id, SET(7d, create_account, userid, device_id))
```

### 关联图谱计算时的问题
在上面的讨论中，我们描述了关联图谱中一度和二度关联计算的原理，并提供了最朴实的算法实现。
但是在实际生产的某些场景中，直接使用上面的算法实现会碰到一些问题。其中最主要的问题有亮点。

#### 近似计算
在实现一度关联的时候，我们的目的是得到一度相邻节点的数量。
为了实现这个目标，我们非常朴实地将每一个不同取值用集合保存下来。
在数据量较小的时候，这种做法简单明了，不会存在什么问题。
但是如果变量的不同取值非常多，那么保存这些值会占用大量的存储空间。
当数据量大到一定程度时，就会使程序的实时计算性能急剧下降。
为了解决这种问题，我们可以采用一类以准确度换取时间和空间复杂度的近似算法，比如hyperloglog算法。
在后面的章节中我们将对这类算法做详细讲解。

#### 数据量大
当数据量较大，但是既要求准确度又要求实时性能时，就必须另想方法了。
这个时候可以采用离线计算与实时计算相结合的方式，
离线部分负责对大部分时间窗口内的数据做预计算，
而实时部分则在离线部分预计算的结果上，对新到数据做增量计算。
Lambda架构是一种用于在大数据场景下，结合离线计算和实时计算达成计算目标的架构模式。
我们将在后面的章节中具体讨论Lambda架构。
但是，类似于Lambda这种架构，不管是在设计上，还是在实现上都极大地增加了实时流系统的复杂性。
所以，如无特别必要，还是勿增实体为好。
这个时候不妨考虑下，在数据量非常大的时候，追求精准结果真的是一件对业务逻辑实现非常必要的事情吗？
说不定通过某种权衡，就可以将问题转化成近似计算的问题了。
