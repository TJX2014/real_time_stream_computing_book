## 流的状态

流在执行过程中，涉及到两种类型的状态，流数据的状态和流信息的状态。

* 流数据状态：在流数据处理的过程中，可能需要处理事件窗口、时间乱序、多流关联等问题，在解决这些问题的过程中，
通常会涉及到对部分流数据的临时保存，并在处理完后将其清理。我们将临时保存的部分流数据称为流数据状态。

* 流信息状态：在对流数据的分析过程中，会得到一些我们感兴趣的信息，
这些信息可能会在后续的流数据分析过程中被继续使用，从而需要将这些信息保存下来。
同时在流数据的处理过程中，还会还不断更新这些信息。我们将这些分析得到并保存下来得数据称为流信息状态。

一种区分这两种状态的方式是，思考这么一个问题，如果我们要"实时计算每个交易事件在发生时过去7天交易的总金额"，该如何做？
我们不能使用流数据窗口来实现"7天"，
因为流数据窗口实际上是控制计算触发（比如另外设定了窗口滑动步长为1秒）和所计算数据的时间范围（这里就是7天）的。
而我们这里要求的是"实时计算每个交易事件"，也就是说在每个事件到达时就立刻触发计算。
如果采用了流数据窗口，虽然也能够实现计算过去7天交易总金额的计算，但是就无法做到每个事件到达时触发计算。
所以，为了不让流的执行本身和我们所要分析的内容耦合起来，我们必需把这两种状态分开。
在计算过去七天交易的总金额这个问题中，就需要另外单独地记录7天交易的历史信息，比如使用一个专门的数据库来记录历史交易信息。

### 流数据状态
流数据状态管理中，比较重要的就是事件窗口、时间乱序和流的关联操作。
流数据状态通常是只保存在内存中，只有在做持久化（checkpoint）时，才写入到磁盘上。
这样做的原因在于，流数据从接收、处理到删除的过程，具有实时、快速、数据量不大和临时的特性，
如果每次接收到一个新事件后，都要将其持久化到磁盘，势必会引起性能的急剧下降。
另外，当流是基于窗口来处理数据时，如果滑动步长很短而窗口较长，实际上会有过多的冗余计算。
比如，在计算"过去7天交易总金额"的这个问题中，窗口为"7天"，如果我们为了尽可能实时，
将窗口滑动步长设置为了"1秒"，那这样做的结果就是，每秒窗口内的数据，
会在"7天除以1秒"这么多次的窗口计算中被重复使用并参与计算。这样无疑浪费了太多的计算资源。

#### 事件窗口
在前面我们自己实现的流计算框架中，事件处理的方式是来一个就处理一个，并没有"窗口"的概念。
但在实际很多场景中，我们并不需要事件每来一个就处理一个，而是按照一定的间隔和窗口来处理事件。
比如每30秒钟计算一次过去五分钟交易总额、每满100个事件计算平均交易金额、统计用户在一次活跃期间点击过的商品数量等等。
对于这些以"窗口"为单元来处理事件的方式，我们需要用一个缓冲区（buffer）临时地存储过去一段时间接收到的事件，
等触发窗口计算的条件满足时，再一次性统一处理这个窗口内的所有事件。等处理完成后，再将过期和以后不再使用的数据清除掉。
在实际生产环境中，还可能出现故障恢复、重启等情况，这些"缓冲区"的数据在必要时还需要写入磁盘，并在重新计算或重启时恢复。
正因为如此，事件窗口处理属于一种"流数据状态"管理。

#### 时间乱序
因为网络和并发的原因，在流计算系统接收到事件时，非常有可能事件已经在时间上乱序了。
比如时间戳为1532329665005的事件，比时间戳为1532329665001的事件先到达流计算系统。
怎样处理这种事件时间乱序的问题呢？
通常的做法就是将收到的事件先保存起来，等过一段时间后乱序的事件到达时，再将其和保存的事件按时间排序，
这样就恢复了事件的时间顺序。
当然，上面的过程中存在一个问题，就是"等过一段时间"到底是怎样等？
针对这个问题有一个非常好的解决方案，就是水印（watermark，参见Flink）。
使用水印解决时间乱序的大致如下：在流计算数据中，按照一定的规律（比如以特定周期）插入"水印"，水印是一个时间戳，
当处理单元接收到"水印"时，表示应该处理所有时间戳在水印之前的事件。
我们通常将水印设置为事件时间戳减去一段时间的值，这样就给先到的时间戳较大的事件一个等待晚到的时间戳较小的事件的机会，
而且确保了不会没完没了地等待下去，而等待时机的大小就是那个减去的时间段了。
当然"水印"这种方案也不是百分百地解决乱序的问题，实在太晚到达的事件当然是过期不侯了。
另外因为需要等待晚到的事件，对当前事件的处理也必然带来一定的时延。

因为解决时间乱序问题也需要借助对流数据本身的缓存和管理，故其是一种"流数据状态"管理。

#### 多流关联
在数据库中，关联操作是一种非常普遍的操作。现在这个概念也越来越多地被延伸到流计算上来。常见的关联操作有join和union。
特别是在实现多流join时，需要先将不同流的部分窗口的数据缓存在内存中，然后以这些窗口数据为基础，
做类似于数据库中多表join的计算，得到关联计算的结果后，再将其以流的方式输出。这样，就完成了多流join操作。
很显然，这个过程中是需要临时保存部分流数据的，故而是一种流数据状态管理。

### 流信息状态
流信息状态是为了记录流数据的处理和分析过程中获得的我们感兴趣的信息，这些信息会在后续的流处理过程中会被继续使用和更新。
就拿前面我们要"实时计算每个交易事件在发生时过去7天交易的总金额"这个例子来说，我们可以将每小时的交易金额记录为一条状态，
这样，当一个交易事件到来时，我们计算"过去7天的交易总金额"，就是将过去7天每个小时的总交易金额读取出来，然后对这些金额记录求总和即可。
在上面这个例子中，将每小时的交易金额记录为一条状态，就是我们说的流信息状态。

与流数据状态主要是存储在内存中不同的是，流信息状态的管理通常依赖于数据库完成。
这是非常合理的，原因在于对于从流分析出来的信息，我们可能需要保存较长时间，而且数据量会更大，
如果将这些信息状态放在内存中，势必会占用过多的内存，这是不必要的。而且，对于保存的信息状态，
我们并不是在每次计算中都会用到，它也会存在冷数据和过期淘汰的问题。所以，对于这种流信息状态的管理，
交给独立的数据库去管理是非常明智的。因为数据库的选择多种多样，而且许多数据库对热数据缓存机制和TTL机制都有非常好的支持。
让专业的人做专业的事，是聪明的决策者应该做的事情。

在接下来的两节中，我们将详细讨论两种非常典型的流信息状态管理方案。
通过这两种方案，我们还会领会到关于分布式系统的两种不同设计思路。

### 总结
流信息状态和流数据状态可以说是从两个不同的维度对"流"的管理。
流数据状态针是从时间序列角度对流的管理，而流信息状态是从空间角度对流的管理。
流信息状态弥补了流数据状态只是对事件在时间序列上做状态管理的不足，将流的状态管理扩展到了任意的空间。
将流数据状态和流信息状态分开，还让我们将流本身的执行机制和数据本身的信息管理机制彻底分离开来。
这使得流计算平台的整体结构变得十分清晰，并且极大地扩展了流计算平台的使用场景和使用范围。
从某种意义上来讲，这种流数据状态和流信息状态分开管理的架构，让我们可以将流计算平台视为一个分布式的JVM。


