## 流计算的性能调优

如果程序是按照流这种方式设计和开发的，那么性能调优实际是一件非常有规律可行的事情。
尤其是在实现了反向压力的情况下，对流计算系统的性能优化，真的可以说是一件轻松愉悦的事情。

### 优化机制
从前面的章节中我们知道，一个流计算作业的执行过程是由DAG决定的。
DAG描述了流计算作业中各个执行步骤，以及数据的流动方向。
因此，根据DAG的拓扑结构，我们就已经对整个程序的执行过程有了一个整体的认识。
接下来针对流计算性能的优化，就是根据这个DAG，按图索骥的过程了。

在实现了反向压力后，整个流计算作业的TPS会受限于DAG中最慢的那个节点，
并且整条流计算作业上各个节点的TPS会最终趋近于一个相同值，也就是最慢节点的TPS。
因此，这个时候考量TPS是不能够知道流计算作业是慢在那个节点上的。
此时需要换个角度，即考量每个节点处理事件的时延。
如果某个节点的处理时延明显高于其它节点的时延，
那就很可能是这个节点导致了系统整体的性能低下。
因此，我们优化的重点首先就是放到这个节点上。
当通过各种手段，比如改进算法、增加资源分配、减少线程竞争等等优化措施，
把这个最慢节点的时延降下来，TPS提升上去后，再次测量系统的整体性能。
如果达到了预期的性能要求，就可以停止优化。
如果还没有达到预期性能要求，则重复上面的过程，再次找到DAG中最慢的节点，优化改进和测试系统性能，直到系统性能达到预期为止。


### 优化工具
工欲善其事，必先利其器。要做好性能优化，首先得准备好一些工具，
并且需要对这些工具有一定的了解。
性能优化的工具可以分为两类，监控工具和压测工具。

#### 监控工具
无监控，不优化。监控是优化的基础，
如果对系统的运行状况没有一个整体的了解，优化是无从做起的。
监控就是我们了解系统运行状况的基础。

##### Metrics
在开始性能调优前，请务必确定在程序的关键逻辑处已经安装了性能监控点。
这是非常重要的，否则监控就成了无本之木，无源之水。
Metrics是一个用于帮助测量Java程序在运行时状况的工具库。
它提供了Gauge、Counter、Meter、Histogram和Timer五种测量手段。
其中，
* Gauge仪表盘，记录变量的当前值，比如记录队列中当前元素的个数。
* Counter计数器，可以通过inc和dec方法来增加或减少其计数值。
* Meter累加计数器，提供了特定时间段内的平均速率，可用于计算TPS一类的指标。
* Histogram直方图，统计数据的分布直方图，并提供了最大、最小和各种分位数等信息，可用于统计时延一类的指标。
* Timer计时器，是对meter和histogram的组合封装，提供更加方便的TPS和时延指标测量方法。
通过Metrics提供的这些测量手段，我们可以在需要关注性能的程序片段处，添加上性能监控点。
之后，这些性能监控点的监控报告可以输出给各种性能监控工具，比如zabbix、jconsole等等。

##### zabbix
或许我们可以用top，dstat, tcpdump等工具来查看系统cup、内存、磁盘和网络的使用状态。
但是在性能调优的时候，单纯地使用这些工具并不能非常好地查看系统在一段时间范围内的运行状态。
为了能够更加完整、全面地分析一个程序在运行时的状况，需要借助于诸如zabbix这类工具构建系统运行状态的时序图。
通过各种资源使用状况的时序图，我们能够方便、快速、直观地定位到程序承压时间、受限资源类型、
JVM做垃圾回收的周期、内存是否泄漏等等一系列的性能问题。

##### JConsole
JConsole是安装好JDK后就自带的Java性能分析工具，可以直接在命令行窗口下以jconsole命令打开。
通过JConsole，可以对JVM实例（即一个独立运行的JVM进程）中的内存使用、线程状态、类和MBeans等各种资源信息进行监控。 
只要JVM实例打开了jmxremote端口，就可以通过JConsole在运行时连接到Java应用程序。JConsole运行时占用资源较少，使用起来非常方便。
但是需要注意的是由于JConsole是一个GUI程序，只有在带图形界面库的操作系统上才能运行。
我们可以通过本地机器上的JConsole，远程连接到服务器上的JVM实例。

##### JVisualVM
与JConsole类似，JVisualVM也是在安装好JDK后自带的Java性能分析工具，可以在命令行窗口下以jvisualvm命令打开。
相比JConsole，JVisualVM的功能更加强大些，并且可以通过安装插件添加更多的JVM性能监控工具。
特别需要说明的是，JVisualVM两个非常惊艳的功能，即抽样器和线程状态可视化展示。
抽样器可以对CPU和内存进行抽样，抽样的结果保存为快照。
通过快照可以一目了然地看到系统中最耗时的函数调用是哪些、函数调用栈各级时延、实例数最多的类是哪些等信息。
这些信息对定位程序在哪个地方最耗时、最耗内存是非常有用的。
线程状态可视化展示则是指JVisualVM能够以彩色条的方式动态展示JVM实例在运行过程中所有线程状态的变化过程。
针对线程状态持续时间和变更过程的分析，可以了解系统中哪些线程最忙碌，哪些线程最空闲，哪些计算逻辑分配的计算资源过少了，
哪些计算逻辑分配的计算资源又过多了，哪些线程处理竞态，哪些线程又在相互等待......
总之，通过线程状态彩色条，再配合抽样器，我们能够非常全面而又生动地理解JVM实例的运行状态。
而这些，都十分有利于我们分析程序的性能，并让性能优化有据可循。
不过功能强大带来的问题是JVisualVM的运行会要求更多的系统资源。
所以如果你要监控的JVM实例中线程和数据较多，就需要给JVisualVM分配更多的内存，否则运行到一半JVisualVM就会因内存不足崩溃了。

#### 压测工具
性能改进时的监控一定是要在系统压力打满的情况下进行，
否则监控工具展现出来的系统状况不具有系统优化的提示作用。
即使是想简单改进无压力状况下系统的处理时延，
实际上也还是得考虑系统在流量高峰时的真实运行情况。

##### Apache JMeter
Apache JMeter是一款基于Java开发的压力和性能测试工具，但也可用于其它领域的测试。
在对微服务做压力测试时，可以通过JMeter启动多个线程对微服务发起HTTP请求，
JMeter提供了多种负载统计报表和可视化工具，让我们可以方便地看到压力测试的运行状况和结果报告。

##### Apache Kafka
在流服务中，可能数据输入源是从诸如Apache Kafka这样的消息队列中而来。
为了方便压力测试，可以预先在Kafka中灌入一批压力测试的输入。
通过修改Kafka分区（partition）的偏移量（offset），可以方便地重放输入数据，而不必每次都灌入新的数据。
这个特性使得Kafka非常适合流计算应用的压力和性能测试。

### 线程状态
理解线程的状态，是做好JVM应用性能优化的基础。
线程状态包含了两个层面的意思，JVM线程的状态和操作系统线程的状态。

#### JVM线程
JVM线程的状态分为新建、运行、阻塞、等待、限时等待和终止。
新建(New)：当通过new Thread()创建一个新的线程对象时，线程就处于新建状态，这个时候线程还没有开始运行。
运行(Runnable)：线程正在被JVM执行，但它也可能在等待操作系统的某些资源，比如CPU。
阻塞(Blocked)：线程因为等待监视器锁而阻塞，获取监视器锁是为了进入同步块（synchronized block/method）或在调用wait方法后重入synchronized。
等待(Waiting)：线程在调用Object.wait、Thread.join或LockSupport.park方法后，进入此状态。waiting状态的线程实在等待另外一个线程执行特定的动作。
限时等待(Timed Waiting)：线程在调用Thread.sleep、Object.wait(timeout)、Thread.join(timeout)、LockSupport.parkNanos
或LockSupport.parkUntil方法后，进入此状态。Timed Waiting状态的线程也是在等待另外一个线程执行特定的动作，但是带有超期时间。
终止状态(Terminated)：线程完成执行后的状态。

在使用JVisualVM监控工具监测JVM实例时，会看到线程状态分成运行、休眠、等待、驻留和监视五种状态。
这五种状态是对JVM线程状态的另一种划分。
运行：对应Runnable状态。
休眠：对应Timed Waiting状态，通过Thread.sleep(timeout)进入此状态。
等待：对应WAITING和TIMED_WAITING状态，通过Object.wait()或Object.wait(timeout)进入此状态。
驻留：对应WAITING和TIMED_WAITING状态，通过LockSupport.park()或LockSupport.parkNanos(timeout)、LockSupport.parkUntil(timeout)进入此状态。
监视：对应BLOCKED，在等待进入synchronized代码块时进入此状态。

#### 操作系统线程
由于Linux操作系统的线程本质上也是进程，它是一种轻量级进程，Linux内核以进程为调度单位，故Linux线程的状态和进程的状态一样。
Linux进程的状态主要有以下几种。
TASK_RUNNING(R)：CPU正在执行的进程，或CPU可以执行但尚未调度执行的进程。如果细分的话，前者是正在运行状态，后者是可运行状态。

TASK_INTERRUPTIBLE(S)：进程因为等待某些事件的发生而处于可中断的睡眠状态。
所谓可中断，是指进程当收到信号（也称为软中断）时，会被提前临时唤醒去执行信号处理逻辑。在完成信号处理后，继续进入睡眠状态。
只有等到它真正关心的事件发生（另外的进程通过wake_up函数触发）时，才会被真正唤醒，变成TASK_RUNNING状态。

TASK_UNINTERRUPTIBLE(D)：此进程状态类似于TASK_INTERRUPTIBLE，但是它不会处理信号。
也就是说进程在睡眠起见，即使收到了信号，也不会醒来。只有等到它真正关心的事件发生（也是另外的进程通过wake_up函数触发）时，
才会醒来，变成TASK_RUNNING状态。
TASK_UNINTERRUPTIBLE和TASK_INTERRUPTIBLE的功能本质上是相同的，只是为了不同场景使用的灵活性而提供的两种不同睡眠策略。

TASK_STOPPED(T)：当进程接收到SIGSTOP或SIGTSTP等信号时，就会在处理这些信号后进入TASK_STOPPED状态。
处于TASK_STOPPED状态的进程没有运行，并且不会被调度运行。
如果接收到SIGCONT信号，进程就会在信号处理完成后，重新变为TASK_RUNNING状态，也就是恢复运行。

TASK_TRACED(T)：TASK_TRACED与TASK_STOPPED状态类似，只是用于调试的场景。当进程正在被其它进程调试追踪时，就进入这种状态。

EXIT_ZOMBIE(Z)：进程已终止，但是还没有被其父进程回收进程信息，这个时候进程就处于僵尸状态。

EXIT_DEAD(X)：进程在经过将僵尸状态后，被父进程调用wait/waitpid回收掉进程信息，就处于EXIT_DEAD状态了，至此进程彻底结束。

#### JVM线程和操作系统线程的关系
当JVM的线程进行IO操作，比如FileOutputStream.writeBytes或FileChannel.transferTo等方法时，
JVM线程的状态是RUNNABLE，但是操作系统的状态不只有TASK_RUNNING，它还会在部分时间段处于TASK_UNINTERRUPTIBLE状态。
JVM的线程与操作系统线程一一对应，其调度是借助操作系统的任务调度器完成的。
JVM线程在触发IO操作时，JVM自身并不会知道这个线程在操作系统层面执行的具体细节，它只知道这个线程正在被执行。
所以对它而言，该线程处于RUNNABLE状态。
但是到操作系统层面后，操作系统（内核）发现这个线程进行了IO相关调用。通常而言，IO操作会触发磁盘或网络等外设的数据传输，
这个过程需要时间，因此操作系统会把这个线程先调度出去，也就是让出CPU来执行其它任务，等到数据传输完成时，再继续调度该线程执行。
在线程等待数据传输完成期间，该线程通常处于TASK_UNINTERRUPTIBLE状态。
这就是为什么进行IO操作的JVM线程处于RUNNABLE状态，但是在操作系统线程层面却会出现TASK_RUNNING和TASK_UNINTERRUPTIBLE两种状态的原因。
JVM线程的IO操作越是密集，对应操作系统线程处于TASK_UNINTERRUPTIBLE状态的时间就越多。
所以，当我们在JVisualVM上看到某个JVM线程长时间处于RUNNABLE时，并不代表它就是一直在被CPU执行，
还有可能是处于IO状态。这个时候，需要借助于top、dstat和zabbix等工具来分析JVM实例（JVM进程）处于用户态和内核态的时间占比、
磁盘和网络IO的吞吐量等信息。
虽然处于RUNNABLE状态的线程并不代表它在执行，还有可能是正阻塞在等待IO操作完成的过程中。
但我们在性能调优时，还是依旧应该让线程处于RUNNABLE状态。
这是因为，处于RUNNABLE状态的线程，要么表示CPU在执行，要么意味着它已经触发了IO操作，只是IO能力不足或者外部资源响应太慢，
才导致了它的等待。
而如果是处于WAITING、TIMED_WAITING或BLOCKED状态，则说明程序可能存在以下问题：
1. 工作量不饱和。比如从输入队列拉取消息过慢。当然也可能是输入本身很少，但是在性能测试和优化时应该让系统处于压力饱和状态。
2. 内耗严重。比如锁使用不合理、synchronized保护范围过大，导致竞态时间过长、并发性能低下。
3. 资源分配不足。比如分配给某个队列的消费者线程过少，导致队列的生产者长时间处于等待状态。
4. 处理能力不足。比如某个队列的消费者处理过慢，也会导致队列的生产者长时间处于等待状态。


整体而言，由于JVM线程是对操作系统线程的封装，其调度也是由操作系统支撑，所以它们的状态大体上是对应和关联的。
比如，处于WAITING状态的JVM线程处于操作系统线程的TASK_INTERRUPTIBLE状态，
WAITING状态的线程可以由其它JVM线程通过notify/notifyAll唤醒，也可以因为InterruptedException被唤醒。
同样的，TASK_INTERRUPTIBLE状态的线程，除了可以由其它线程唤醒，也可以由信号（软中断）来唤醒。

但由于JVM是在用户态对线程进行管理和描述，所以失去了底层的细节。
这就导致JVM线程在一个状态期间，可能会出现多种操作系统线程状态。
比如前面提到的，处于RUNNABLE状态的JVM线程可以处于操作系统线程的TASK_RUNNING和TASK_INTERRUPTIBLE状态。

### 优化方向
在确定了性能的瓶颈处之后，就是采取措施来改进程序性能了。
通常性能优化可以从资源、算法、并发与竞态这三个方面来考虑。

#### 资源
程序在运行时的资源，主要包括CPU、内存、磁盘IO和网络IO四个方面。
* CPU：调整线程数和线程调度的优先级，可以调整分配给计算任务的CPU资源。
* 内存：通过设置启动参数，可以配置JVM内存使用和垃圾回收策略。
比如用-Xms和-Xmx配置JVM的堆，用-Xss配置线程的栈。还可以通过其它参数，配置JVM垃圾回收（GC）的策略。
另外在程序开发过程中，采取及时释放无用对象、设置缓存TTL、避免内存泄漏等措施，也可以优化内存使用。
* 磁盘IO：通过异步和批次操作，可以提高磁盘读写性能。还可以使用缓存，减少不必要的磁盘IO操作。
在必要时，可以采用性能更好、支持随机读写的磁盘，比如SSD。
* 网络IO：同样异步和批次操作，可以提高网络IO性能。如果通过监控确定带宽已用满，就需要增加带宽了。

#### 算法
算法改进是一个与特定计算任务强相关的事情。
比如采用Hyperloglog近似算法来改进关联图谱中一度关联度的计算。
由于这个与具体的计算任务强相关，因此在此不再展开。
在后面关于实时流中特种计算的章节中，我们会针对反欺诈场景中常用的特征计算算法做讨论，并针对部分算法做优化的讨论。

#### 并发与竞态
如果在程序中为了保证并发安全，使用了诸如锁（Lock）一类的同步方案，
那么就需要检查是不是因为多线程竞争导致程序性能下降。
前面提到，在流计算过程中，通过队列隔离计算逻辑，并且尽量使用不可变变量（Immutable Variables）来减少了竞态发生。
所以如果还有因为竞态影响性能的问题，很有可能是程序的编写不当造成。
特别是在使用一些第三方库的时候，一定要对所使用第三方库的内部工作原理有最基本的认识。
比如它是否是线程安全的，是否是高并发设计的。
如果实在不能确定，还是采用稳妥的方式处理更好，比如以线程局部量的方式来使用。

另外需要注意的是，高并发设计与线程安全是两个不同的概念。
支持高并发设计意味着一定线程安全，但是线程安全并不一定是高并发设计的。
比如JDK中的Hashtable是线程安全的，但它是通过在所有Map接口方法上加synchronized这种粗鲁的同步方式实现的。
因此在高并发场景下，Hashtable性能会非常糟糕。
而ConcurrentHashMap则采用了更加精细设计的分段加锁来实现线程安全和高并发访问。
在高并发场景下，不同段的访问互不影响，使ConcurrentHashMap的性能表现依旧非常出色。
