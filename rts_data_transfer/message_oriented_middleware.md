## 消息中间件
在计算机领域，但凡在两个不同应用或系统间传递的数据，都可以称之为消息。
在应用层，消息可以表现为字符串、JSON对象和AVRO对象等等。
当在两个系统间传递消息时，应用层用于表示消息的对象先被序列化为字节数组，
然后经过网络传输，最后由消息接收方反序列化，恢复为应用层对象。

或许我们可以直接在tcp/udp等网络协议的基础上，轻松地实现两个系统之间的消息传递。
但问题其实并没有表面看上去这么简单。
考虑下消息传递的性能、消息传达的可靠性、系统重启时消息的持久化和恢复、消息量暴增时的性能扩展、多种不同平台之间的消息协同等等。
可以说，当你完成所有这些特性的开发后，一定已经忘记了你最初的业务目标是什么。

这时候，就是消息中间件发挥重要作用的时候了。
消息中间件替我们解决了消息传递过程中的所有问题，我们只需要使用相应的客户端发送和接收消息即可，
其它事情都交由消息中间件这个"经纪人"一手包办。

必须提到的是，以消息中间件为核心的架构模式SOA，曾经深深影响过一代系统开发人员。
直到现在SOA模式还在许多企业级架构中发挥着重要作用。
虽然SOA模式不是本章重点，但仍然建议读者自行查阅相关资料了解其历史。毕竟"以史为鉴,可以知兴替"。

### 发布/订阅模式
发布/订阅模式是消息中间件最主要的工作方式。
消息生产者将消息进行分类后发布到代表各个类别的主题（Topic）上，
消息消费者则订阅其感兴趣的主题，然后按消息产生顺序依次读取消息。

发布/订阅模式使得消息生产者和消费者之间的通信不再是一种点到点的传输，
而是由消息中间件作为代理人统一管理消息的接收、组织、存储和转发。
这样既减少了系统中所有生产者和消费者之间的连接数量，也减小了生产者和消费者之间的耦合，从而降低了整个系统的复杂度。

### 消息模式(schema)
消息中间件替我们包揽了消息传递过程中的大部分事情，只剩下最后一件事情必须交由开发者决定，这就是消息模式。
所谓消息模式，也可以说是消息的定义。再说白点，就是定义消息有哪些字段、字段的类型、字段的排列顺序、字段是否必须等等。
或许我们觉得这不就是定义个消息吗，列出个文档不就可以了。
但是在实际产品开发中，消息模式随产品版本的迭代和更新，有时候会成为一个非常恼人的问题，就像睡觉时耳边嗡嗡做势的蚊子。
所以这里我们还是要讨论下几种消息模式的处理方式。

#### 无模式（弱模式）
无模式（弱模式）也是一种模式，很多Java开发者尤其喜欢用类来表达一个实体，这是非常好的习惯。
但是像Python这样动态语言的开发者则并不是十分热衷于预先规定一个对象必须有哪些字段，
他们只需要大致知道一个对象有哪些字段，然后在程序需要某个字段的地方有那个字段即可。
当数据在实时流系统中被逐步处理和信息增强时，一些临时字段、可选字段、推导字段会逐渐附加到消息上，
这个时候，使用部分无格式的消息模式不妨是一种好的选择。
以JSON为代表的一类数据格式是无模式消息的典型，也就是说我们不需要schema文件就可以将其从字节数组反序列化为JSON对象。
笔者将这种使用JSON表示数据，直接操作JSON字段，实现数据处理逻辑的设计和开发方式，称之为"无schema编程"。
当在处理流式数据过程中，需要增加一些消息字段时，这是一种方便灵活的解决方案。
但需要注意的是，无schema编程对程序开发者要求较高，非常需要注意在程序的各个地方检查相关处理逻辑必要字段的完整性和合法性。
另外，还要遵守"数据不变性原则"，即可以增加消息的字段，但是不要修改和覆盖消息的原有字段。
换言之，我们对消息的处理仅仅是增强信息，而不是修改信息。

#### 强模式
定义严格的数据模式，是大家都喜闻乐见的事情，不仅仅是开发，也包括产品、测试、运维和售前。
以Avro、Thrif、Protocol buffers为代表的数据组织方案，是强消息模式的代表。
强模式的好处在于字段在反序列化为对象的时候，就自动对字段的完整性进行了检查，再配合类的定义，使用起来更加方便、高效和安全。
当采用强模式表达消息时，应该尽可能地选择即支持前向兼容，也支持后向兼容的方案。
所谓前向兼容，是指当schema新加字段时，以旧schema保存的二进制数据如果用新schema反序列化，新加字段应该设置为默认值，而不是抛出异常。
所谓后向兼容，是指当schema新加字段时，以新schema保存的二进制数据如果用旧schema反序列化，新加字段应该被忽略，而不是抛出异常。
这样做的原因在于，实际生产中线上系统非常可能混合新旧两种schema对应的二进制数据。
比如，在新版本客户端SDK发布后，市面上还是会有很多旧版本客户端SDK的用户。
虽然Avro、Thrif、Protocol buffers等序列化框架都支持前后向兼容，
但是产品迭代更新schema时，还是应该尽量保证消息字段的一脉相承，并且应该仔细阅读各种序列化框架前后向兼容的限制条件，
不要随意删除字段、修改字段名称和调整字段顺序，否则稍不注意就会出现反序列化结果和预期不一致的问题。

#### 版本控制
任何时候，给接口或协议添加版本控制都是明智之举，消息模式亦是如此。
在消息模式的首位添加一个版本控制字段总归是好的，这样当数据模式被改得面目全非时，
依旧能够通过不同版本执行不同逻辑分支的方式留下处理所有新旧格式消息的余地。
另外版本控制也有助于数据处理失败时的问题追溯和分析。


### 选择消息中间件的考量因素

在第一章中，我们已经讨论了在消息中间件选型时，一些基本的考量因素，也就是吞吐量、延迟、高可用、持久化和水平扩展。
这里，我们还需要补充几个在实际开发中需要考虑的问题。


#### 消息传达可靠性
大多数流计算平台都会对消息传达可靠性作出一定程度的保证，比如尽力而为、至少一次或精确一次等。
这点我们在前面对比各种开源实时流计算平台时已有所讨论。
作为流计算系统中数据的传输中枢，消息中间件自身对消息传递可靠性的承若亦是如此。

很多开发者认为"精确一次"理所当然是最好的消息可靠性保证，有了它就不用考虑任何消息传递失败的问题。
但笔者认为，不管是流计算平台，还是消息中间件，
大多数情况下都不要过度依赖消息中间件能够提供给你"精确一次"的保证。
一方面保证"精确一次"会比较显著地降低系统性能，
另一方面不同的系统其所承若的"精确一次"语义都或多或少有所区别，使用起来还会有一定限制。

基本上，所有"精确一次"级别的可靠性保证，都是通过框架内部的一套封闭并且完备的逻辑来实现。
所以当开发者想要使用"精确一次"级别的可靠性服务时，就必然是限定在框架提供的SPI或服务下完成。
比如Storm的ACK机制和Trident，Flink的checkpoint机制和Keyed state及Operator state等等。
相比实现一个独立而且完整的模块，一边开发业务逻辑一边还得照顾框架本身的工作机制，实在是件琐碎的事情。
另外，当我们需要与不受框架约束的外部存储（比如文件、数据库等）打交道时，就脱离了流计算框架的保护，
到头来还是需要开发者自己去保证消息的exactly once。
如果我们不明真相，以为框架提供了"精确一次"就万事大吉，忽略了与外部存储交互时对失败的处理，
开发出来的程序就很不安全了。

总的来说，消息中间件至少应该能够提供"至少一次"级别的传达可靠性。
至于"精确一次"级别的可靠性，其实现会更加复杂，使用起来也会有更多约束条件，性能也需要考量。
"精确一次"和"至少一次"之间的差异，就像lock和try lock之间的区别。
后者相比前者，选择它时更显乐观，但使用它时需要更加谨慎。
如此方可在保证结果正确的同时，获得更好的性能表现。


#### 消息重放
昨日重现，或者朝花夕拾，都是美好的事情。抑或悔不该杀了那华佗，可惜这世上没有后悔药。
消息重放，是流计算系统中时不时会遇到的问题。
重放的原因可能是某段时间消息处理程序崩溃，需要补跑数据，也可能是模型更新，需要重新训练模型参数。
不用多想，实现消息重放最"直接"的方式，当然就是将消息从其保存的地方重新拉出来，然后再次发往消息中间件。
但这种方法可能并非最优。
将消息从块存储设备里面读出来，还原消息格式和顺序，再重新发往消息中间件，整个过程都涉及比较多的定制开发。
特别是当需要重放的主题比较多时，定制开发工作会变得十分繁琐。
好在现在越来越多的消息中间件开始支持数据存储功能。
也就是说，它们不再是简单的消息发布-订阅系统，同时还是流数据存储系统，将一定时间范围内的数据流保存下来。
当需要重放消息时，只需将"播放点"设置到重放开始的地方，即可完美复现之前的数据流。

### 总结
本章介绍了消息中间件的工作原理，并尝试探讨了消息中间件在使用过程中的几个通用原则和问题。
在接下来的章节中我们将以Apache Kafka为例，详细讨论消息中间件在实时流计算系统中的运用。


