## 做不到实时的原因
虽然本书的主题是实时流计算，但是不得不承认的是，我们真实面对的绝大部分问题在当前普遍的硬件计算能力下，
即使采用分布式、大数据等技术，也不能直接实时计算出想要的结果。
那是不是说面对这些问题，就该彻底放弃实时计算的念头呢？不是的。
虽然不能直接计算问题的答案，但是我们还是可以通过增量计算的方式来获得问题的答案。
即使有时候这些答案具有迟滞性和近似性，但是只要它们能够带来尽可能最新的信息价值，那它们也是有用的。

整体而言，做不到实时计算的原因可以分成三个方面：算法复杂度高、计算资源受限和数据量过大。

### 算法复杂度高
有些时候，我们要解决的问题本身就具有复杂性。
比如在风控分析时，需要统计社交网络中二度联系人之间的关联关系。
在异常检测时，需要随着时间增长不断训练或更新统计模型或机器学习模型的参数等等。
这类问题算法的复杂度通常会大于O(N)。当N较大时，计算的时延在实时分析中变得不可接受。也就失去了实时的意义。


### 计算资源受限
通常实时计算的资源包含了CPU、内存和IO。当计算资源中的一种或多种已经用满时，
计算任务会出现排队等待的情况，这会增加处理的时延。
因此，针对线上系统的监控是一件非常重要的事情。
很多时候，监控系统的存在不仅会避免线上事故的发生，还会对我们做出性能优化做出改进提示。

### 数据量过大
大多数情况下，计算不能实时完成，数据量过大是主要原因。
一方面当数据量过大时，即使是时间复杂度为O(log(N))级别的算法，也可能因为数据分布在多个节点上，
需要垮主机远程访问，带来过多IO操作，导致计算时延增大。
另一方面，数据量过大不仅给存储管理带来复杂性，还会对计算造成影响，比如频繁GC造成JVM频繁卡顿。

## 如何解决
针对上面三种不能做到实时计算的原因，或许我们能够通过具体问题具体分析的方式来逐一解决。
但是，有没有一种普遍适用的方法来处理这类问题呢？答案是有的，这就是我们要讲的Lambda架构。

但在具体讲Lambda架构之前，我们一定记住一条"铁纪"。
这就是，如果我们承若要做一个实时流计算系统，
那就一定要把这个流计算系统中的任何一个环节做成实时响应的，一定不能让其中的某个环节是非实时的。
这是因为，一旦流计算系统中的某个环节是非实时的，根据"木桶原理"，
这个流计算系统的处理速度就受限于这个非实时环节了，那么整个流计算系统也会变成非实时的，
系统其它部分做出的所有实时计算努力也失去了意义。
记住这条"铁律"，还可以对我们改进整条流计算系统的性能带来帮助。
因为只要发现某个环节处理慢了，就可以快速定位到这个环节，然后对这个环节做针对性的性能改善，
比如改进算法、分配更多计算资源。通过不断地迭代这个过程，可以持续改进整条流计算过程的性能。


